# Summary

The source code in this repository comprises two fully&ndash;featured public&ndash;key cryptosystems, and implements many public&ndash;key primitives one might expect to find in a cryptography library, such as key generation, encryption and digital signature. Implementations include the classic [_Diffie-Hellman_](https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange) (DH) key agreement protocol, the [_Rivest-Shamir-Adleman_](<https://en.wikipedia.org/wiki/RSA_(cryptosystem)>) (RSA) cryptosystem, and an elliptic curve cryptosystem based on the Standards for Efficient Cryptography (SEC) Group's [_Recommended Curve Domain Parameters_](https://www.secg.org/sec2-v2.pdf).

# Structure and Layout

The source code, written in Python, is organized into a package hierarchy, as illustrated in the following diagram:

<pre>
src/
 |_api
 |_core
 |_tests
    |_api
    |_core
 |_README.md (the file you are currently reading)
</pre>

The top&ndash;level `src` folder represents the root of this package, and contains the sub&ndash;packages `api` and `core`. Together, these two packages implement the services of the cryptosystems mentioned in the summary section of this document. The `tests` package, which itself is subdivided into `api` and `core` packages, contains unit tests for the modules in their corresponding `src`&ndash;level packages.

## The `core` Package

The modules in the `core` package implement the low&ndash;level cryptographic primitives on which the code in the `api` package depends.

With very few exceptions, the code in this package is free of dependencies on external, third&ndash;party modules or libraries (modules such as `math` and `os` could not be avoided, but the services they provide are so essential that they could not be feasibly omitted).

Following is a short description of each module in the `core` package:

- [curves.py](https://github.com/dchampion/crypto/blob/master/src/core/curves.py) &mdash; The collection of elliptic curves specified in the Standards for Efficient Cryptography Group's (SECG) [_Recommended Elliptic Curve Domain Parameters_](https://www.secg.org/sec2-v2.pdf). These include Koblitz curves, and those derived from verifiably random seeds.

- [dh.py](https://github.com/dchampion/crypto/blob/master/src/core/dh.py) &mdash; An implementation of the classic Diffie-Hellman (DH) key agreement protocol based on multiplicative groups.

- [ec.py](https://github.com/dchampion/crypto/blob/master/src//core/ec.py) &mdash; Implementations of the elliptic curve Diffie-Hellman (ECDH) and elliptic curve digital signature algorithms (ECDSA).

- [euclid.py](https://github.com/dchampion/crypto/blob/master/src/core/euclid.py) &mdash; Efficient algorithms for computing the greatest common divisors (GCD), least common multiples (LCM) and modular multiplicative inverses of positive integers.

- [primes.py](https://github.com/dchampion/crypto/blob/master/src/core/primes.py) &mdash; Efficient algorithms for primality testing and prime number generation.

- [prng.py](https://github.com/dchampion/crypto/blob/master/src/core/prng.py) &mdash; A cryptographically secure pseudo-random number generator.

- [rsa.py](https://github.com/dchampion/crypto/blob/master/src/core/rsa.py) &mdash; Implementations of the Rivest-Shamir-Adleman (RSA) cryptosystem, including encryption, decryption, digital signature and verification procedures.

- [util.py](https://github.com/dchampion/crypto/blob/master/src/core/util.py) &mdash; Efficient algorithms for exponentiation of integer bases to powers of very large exponents.

## The `api` Package

The modules in the `api` package are effectively a very thin wrapper around the [_Crypto.PublicKey_](https://www.pycryptodome.org/src/public_key/public_key#) package of the [pycryptodome](https://www.pycryptodome.org/src/introduction) project; a widely used open&ndash;source cryptography library for Python. The only difference is that the services provided by the `api` package (specifically, the objects [_DsaKey_](https://www.pycryptodome.org/src/public_key/dsa), [_RsaKey_](https://www.pycryptodome.org/src/public_key/rsa) and [_EccKey_](https://www.pycryptodome.org/src/public_key/ecc)) are constructed using primitives in this project's `core` package.

Among other things, this design permits keys generated by primitives in the `core` package to be used in protocol&ndash;level cryptographic services, or to be exported to industry&ndash;standard formats such as [DER](https://en.wikipedia.org/wiki/X.690#DER_encoding) and [PEM](https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail).

## The `tests` Package

The `tests` package is subdivided into `api` and `core` sub&ndash;packages; each containing unit tests for its respective source package.

# Exercise the Code in the `core` Package

Interacting with the code in the `core` package is the best way to learn the implementation details of the lowest&ndash;level cryptographic primitives. There are three principal ways to exercise the code in this package, with instructions for each to follow:

1. Run the unit tests (ok)

2. Run and interact with the code in a Python REPL (better)

3. Run and interact with the code in the Jupyter notebooks (best)

For any of these strategies to work, Python (version 3.9.7 or greater) must be installed on your computer.

## 1. Unit Tests

For every source code module (e.g., `rsa.py`) in the `core` package, there is a corresponding unit test (e.g., `rsa_test.py`) in the `tests.core` package.

To run a test on a single module (e.g., `rsa.py`), start a command&ndash;line shell (e.g., _CMD_ on Windows, or _bash_ on Linux or MacOS), navigate to the root package (i.e., the `src` folder of this repository) and type:

<pre>
$ python -m tests.core.rsa_test
running all tests in tests.core.rsa_test
  8 rounds of generate_rsa_prime started in parallel processes
  8 rounds of generate_rsa_prime finished in parallel processes
test_generate_rsa_prime passed
  8 rounds of generate_rsa_key started in parallel processes
  8 rounds of generate_rsa_key finished in parallel processes
test_generate_rsa_key passed
  8 rounds of encrypt_decrypt started in parallel processes
  8 rounds of encrypt_decrypt finished in parallel processes
test_encrypt_decrypt passed
  8 rounds of sign_verify started in parallel processes
  8 rounds of sign_verify finished in parallel processes
test_sign_verify passed
test_full_protocol passed
test_rsa_class passed
finished all tests in tests.core.rsa_test
$
</pre>

Alternatively, to run _all_ the tests in the `tests.core` package, from the same folder type:

<pre>
$ python -m tests.core.all_tests
running all tests in tests.core
  8 rounds of dh_setup started in parallel processes
...
(many more lines of output)
...
finished all tests in tests.core
$
</pre>

If [pytest](https://pytest.org) is installed, you can achieve the same result simply by typing `pytest tests/core` at a shell prompt (to install `pytest`, type `pip install pytest`).

<pre>
$ pytest tests/core
================== test session starts =======================
src\tests\core\dh_test.py ....                          [  9%]
src\tests\core\ec_test.py ...............               [ 46%]
src\tests\core\euclid_test.py ......                    [ 60%]
src\tests\core\primes_test.py ......                    [ 75%]
src\tests\core\rsa_test.py .......                      [ 92%]
src\tests\core\util_test.py ...                         [100%]
============== 41 passed in 710.75s (0:11:50) ================
</pre>

## 2. Python REPL

For a better experience, start a Python REPL in the `src` folder to interact with the source code directly.

In the following example, the elliptic curve cryptosystem is used to generate a keypair, sign a message with the private key, and then verify the signature with its corresponding public key.

<pre>
$ python
>>> from core import ec
>>> private_key, public_key = ec.generate_keypair()
>>> signature = ec.sign(private_key, "When in the course of human events...")
>>> ec.verify(public_key, "When in the course of human events...", signature)
True
>>> ec.verify(public_key, "When in the course of bovine events...", signature)
False
</pre>

Each of the principal modules (i.e., `dh`, `ec` and `rsa`) features a class&ndash;based API that hides the lower&ndash;level details of the module&ndash;based API from the user. For example, using the class&ndash;based API, the code snippet above would be rewritten as follows:

<pre>
$ python
>>> from core import ec
>>> key = ec.make_key()
>>> signature = key.sign("When in the course of human events...")
>>> key.verify(key.public_key(), "When in the course of human events...", signature)
True
>>> key.veriry(key.public_key(), "When in the course of bovine events...", signature)
False
</pre>

## 3. Jupyter Notebooks

For the best experience, load and run the Jupyter notebooks (files with _.ipynb_ extensions located in the [doc](https://github.com/dchampion/crypto/tree/master/doc) folder of this repository). In addition to describing the various cryptographic protocols in detail, these notebooks allow the reader to interact with the source code in real time (to run a Jupyter server, consult the link at [_jupyter.org_](https://jupyter.org/) or Google's [_Colaboratory_](https://colab.research.google.com/) project).

# Exercise the Code in the `api` Package

To utilize higher&ndash;level services suitable for protocol&ndash;level use cases, run the code in the `api` package.

Note that to run the code in this package, the [pycryptodome](https://www.pycryptodome.org/src/introduction) package must be installed in your Python environment (type `pip list` to see a list of packages currently installed in your environment).

If `pycryptodome` is not installed, it is recommended you install it in a virtual environment so as not to interfere with or otherwise pollute your global Python environment.

Navigate to the `src` folder in an operating system shell, and type the following commands to create and activate your virtual environment:

<pre>
$ python -m venv api/.venv
$ source api/.venv/scripts/activate
$ pip install -r api/requirements.txt
</pre>

When you are finished with your session, you can deactivate your virtual environment by typing `deactivate` at the shell prompt. To re&ndash;start your virtual environment, you need only type `source api/.venv/scripts/activate`.

In the following example, an elliptic curve keypair, based on the [NIST&ndash;sanctioned Secp384r1 curve parameters](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf), is generated and exported to industry&ndash;standard file formats.

<pre>
$ python
>>> from api import ec_w
>>> ec_key = ec_w.construct("secp384r1")
>>> f = open("ec_key.der", "wb")
>>> f.write(ec_key.export_key(format="DER", passphrase="abc", protection="PBKDF2WithHMAC-SHA1AndAES128-CBC")) 
274
>>> f.close()
>>> f = open("ec_public_key.pem", "wt")
>>> f.write(ec_key.public_key().export_key(format="PEM"))
214
>>> f.close()
</pre>

The code above creates two files: `ec_key.der`, a passphrase&ndash;protected [DER](https://en.wikipedia.org/wiki/X.690#DER_encoding) file containing both the private and public keys, and `ec_public_key.pem`, a [PEM](https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail) file containing only the public key.

Finally, the unit tests in the `tests.api` package are designed to ensure that keys provided by the `api` package, which are constructed from primitives generated by modules in the `core` package, are not susceptible to any _known_ vulnerabilities. To run these tests, type `python -m tests.api.all_w_tests` from the `src` folder (to use `pytest`, you will need to install it in the same virtual environment in which you installed `pycryptodome`; i.e., with `pip install pytest`).

# Documentation

The source code in these packages is thoroughly documented, both in the form of _docstrings_ at the module and function level, which describe at a high level the behavior of the module or function; and inline comments embedded in the function implementations, which are intended to clarify the effect of a particular statement or group of statements immediately following the comment.

The unit tests are also documented, notably in docstrings contained in the full&ndash;protocol tests of [dh_test.py](https://github.com/dchampion/crypto/blob/master/src/tests/core/dh_test.py), [rsa_test.py](https://github.com/dchampion/crypto/blob/master/src/tests/core/rsa_test.py) and [ec_test.py](https://github.com/dchampion/crypto/blob/master/src/tests/core/ec_test.py). These tests exercise the highest&ndash;level primitives in the `core` package by simulating sessions from start to finish; from parameter&ndash;setup and key&ndash;negotiation to secure, authenticated message&ndash;exchange between parties over insecure channels.

Better still, the Jupyter notebooks in the [doc](https://github.com/dchampion/crypto/blob/master/doc) folder of this repository demonstrate the use of this library in application&ndash;level simulations.

# Why Python?

Python has a built&ndash;in multiprecision library featuring large-integer support; a prerequisite for industrial&ndash;strength computational cryptography. Using a language such as C, C++ or Java would have required the services of a third&ndash;party, external library, which I tried to avoid.
