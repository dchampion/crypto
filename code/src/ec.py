"""
An implementation of the elliptic curve Diffie-Hellman (ECDH) and the elliptic curve digital
signature algorithms (ECDSA), based on the Standards for Efficient Cryptography Group's (SECG)
secp256k1 elliptic curve.
"""

from types import NoneType
import euclid
import primes
import math
import prng
import util

# secp256k1 elliptic curve parameters (y**2 = x**3 + ax + b % p)
_p = 2**256 - 2**32 - 977
_a = 0
_b = 7
_Gx = 55066263022277343669578718895168534326250603453777594175500187360389116729240
_Gy = 32670510020758816978083085130507043184471273380659243275938904335757337482424
_G = [_Gx, _Gy]
_n = 115792089237316195423570985008687907852837564279074904382605163141518161494337
_h = 1

# Point at infinity
_i = [None, None]

# Global curve point [_x, _y] list indices.
_x = 0
_y = 1

def new_curve(p, a, b, Gx, Gy, n, h, B_iters=100):
    """
    Redefines the default (secp256k1) elliptic curve parameters, and validates
    the new ones. The parameter p is the modulus, a and b the coefficients,
    Gx and Gy the XY coordinates of the generator point, n the order of the
    point [Gx, Gy] and h the cofactor of the group generated by [Gx, Gy].
    The equation for an elliptic curve is y**2 = x**3 + ax + b % p, where x
    and y are the variables, a and b are the coefficients, and p is the modulus.
    """
    global _p, _a, _b, _Gx, _Gy, _n, _h, _G

    _p, _a, _b, _Gx, _Gy, _n, _h = p, a, b, Gx, Gy, n, h
    _G = [_Gx, _Gy]

    _validate_curve_params(B_iters)

def add(pt1, pt2):
    """
    Returns the sum of points pt1 and pt2 on the curve, according to the addition
    rules of elliptic curves; i.e., (a) the point at infinity if pt1 and pt2 are
    both the point at infinity, (b) pt2 if pt1 is the point at infinity, (c) pt1
    if pt2 is the point at infinity, (d) the point at infinity if pt1 and pt2 share
    the same x-coordinate, or (e) the sum of pt1 and pt2 on the curve.
    """
    _validate_pt(pt1)
    _validate_pt(pt2)

    if pt1 == _i and pt2 == _i:
        [x, y] = _i
    elif pt1 == _i:
        [x, y] = pt2
    elif pt2 == _i:
        [x, y] = pt1
    elif pt1 == pt2:
        [x, y] = double(pt1)
    elif pt1[_x] == pt2[_x]:
        [x, y] = _i
    else:
        [x, y] = _add(pt1, pt2)
    
    return [x, y]

def _add(pt1, pt2):
    slope = ((pt2[_y] - pt1[_y]) * euclid.inverse((pt2[_x] - pt1[_x]) % _p, _p)) % _p
    x = (slope**2 - (pt2[_x] + pt1[_x])) % _p
    y = ((slope * pt2[_x]) - (slope * x) - pt2[_y]) % _p
    return [x, y]

def double(pt):
    """
    Returns the sum of point pt and itself on the curve. If pt is the point at
    infinity, returns the point at infinity.
    """
    _validate_pt(pt)

    if pt == _i:
        return pt

    return _double(pt)

def _double(pt):
    slope = (((3 * pt[_x]**2) + _a) * euclid.inverse(2 * pt[_y], _p)) % _p
    x = (slope**2 - (2 * pt[_x])) % _p
    y = ((slope * pt[_x]) - (slope * x) - pt[_y]) % _p

    return [x, y]

def generate_keypair():
    """
    Returns a private key d and its corresponding public key Q, where d is a
    randomly generated positive integer in the range 1 <= d < ord(G) (where 
    ord(G) is the order of the generator point), and Q is the point on the
    curve resulting from d point-additions of the generator. d, the private
    key, must be kept secret by the caller of this function. Q, the public key,
    may be shared freely.
    """
    d = _n
    while not is_valid_d(d):
        d = prng.randbits(_n.bit_length())

    return d, _fast_point_at(d)

def generate_session_key(d_priv, Q_pub):
    """
    Returns a hashed byte array to be used as a session key in a symmetric cipher
    agreed upon by both parties in the setup phase. This key must be kept secret.
    """
    assert is_valid_d(d_priv)
    validate_pub_key(Q_pub)

    # Compute a session key using the essential property of DH (i.e., multiplying
    # the other party's public key Q_pub by this party's private key d_priv).
    ki = x_times_pt(d_priv, Q_pub)

    # The session key is hashed in order to obscure any mathematical structure
    # in ki that could be exploited by an adversary if it were to be leaked.
    return util.hash(ki)

def is_valid_d(d):
    return isinstance(d, int) and 1 <= d < _n

def sign(m, d):
    """
    Returns a signature S&mdash;a tuple of the form (r, s)&mdash;that is computed
    by signing the message m with a private key d.
    """
    s = 0
    while s == 0:
        r = 0
        while r == 0:
            # k is the ephemeral (i.e., one-time use) key.
            k, R = generate_keypair()
            assert 0 <= R[_x] < _p

            # r is the x-coordinate of R; the first element of the tuple (r, s)
            # returned by this function.
            r = R[_x] % _n

        # Convert m to an integer representative of its hash.
        e = hash_to_int(m)

        # Compute the second element of the tuple (r, s) returned by this function.
        s = (euclid.inverse(k, _n) * (e + d * r)) % _n

    return r, s

def verify(m, S, Q):
    """
    Returns True if the signature S&mdash;a tuple of the form (r, s)&mdash; is valid
    for the message m and a public key Q; otherwise returns False.
    """
    r, s = S[0], S[1]

    # Convert m to an integer representative of its hash.
    e = hash_to_int(m)

    u1 = (e * euclid.inverse(s, _n)) % _n
    u2 = (r * euclid.inverse(s, _n)) % _n

    # Recover the point computed in the signing operation.
    R = add(x_times_pt(u1, _G), x_times_pt(u2, Q))
    assert R != _i

    v = R[_x] % _n

    return v == r

def hash_to_int(m):
    """
    Converts a message m to an integer representation of its hash.
    """
    h = util.hash(m)
    hi = int.from_bytes(h, byteorder="big")

    if _n.bit_length() >= hi.bit_length():
        e = hi
    else:
        # Use only the leftmost _n bits if _n is smaller than m.
        e = hi >> (hi.bit_length() - _n.bit_length())

    return e

def validate_pub_key(Q):
    """
    Recommended public key validation from the Standards for Efficient Cryptography
    Group's (SECG) specification, "SEC 1: Elliptic Curve Cryptography, Version 2.0"
    (https://www.secg.org/), section 3.2.2.1 (Elliptic Curve Public Key Validation
    primitive).
    """
    _validate_pt(Q)

    # Q cannot be the point at infinity.
    assert Q != _i

    # Q's coordinates must be in the interval [0, p-1]
    assert 0 <= Q[_x] < _p - 1
    assert 0 <= Q[_y] < _p - 1

    # Q must be on the curve.
    assert Q[_y]**2 % _p == (Q[_x]**3 + (_a*Q[_x]) + _b) % _p

    # The order _n of the curve group times any Q on the curve must equal the
    # point at infinity (redundant, and costly, if _h == 1).
    if _h > 1:
        assert x_times_pt(_n, Q) == _i

def _fast_point_at(d):
    """
    Returns the point on the curve at d point-additions of the generator point,
    where d is a positive integer in the range 1 <= d < ord(G), and ord(G) is the
    order of the generator. In contrast with the function _point_at, this function
    runs in O(log2(n)) (logarithmic) time.
    """
    assert isinstance(d, int) and 0 < d <= _n

    return x_times_pt(d, _G)

def x_times_pt(x, pt):
    """
    Returns the point on the curve at x point-additions of the start point pt, or
    the point at infinity...
    """
    _validate_pt(pt)
    assert isinstance(x, int) and x > 0

    start_pt = pt
    for i in range(x.bit_length()-2, -1, -1):
        pt = double(pt)
        if (x>>i) & 1:
            pt = add(start_pt, pt)

    return pt

def _point_at(d):
    """
    Returns the point on the curve at d point-additions of the generator point,
    where d is a positive integer in the range 1 <= d < ord(G), and ord(G) is the
    order of the generator. In contrast with the function _fast_point_at, this function
    runs in O(n) (linear) time.
    """
    assert isinstance(d, int) and 0 < d <= _n

    pt = _G
    for _ in range(1, d):
        pt = add(_G, pt)

    return pt

def _validate_pt(pt):
    assert isinstance(pt, list)
    assert len(pt) == 2
    assert (isinstance(pt[_x], int)      and isinstance(pt[_y], int))\
        or (isinstance(pt[_x], NoneType) and isinstance(pt[_y], NoneType))

def _validate_curve_params(B_iters=100):
    """
    Recommended curve parameter validation from the Standards for Efficient Cryptography
    Group's (SECG) specification, "SEC 1: Elliptic Curve Cryptography, Version 2.0"
    (https://www.secg.org/), section 3.1.1.2.1 (Elliptic Curve Domain Parameters over
    Fp Validation Primitive).
    """
    assert B_iters >= 1
    assert 0 <= _a  <= _p - 1
    assert 0 <= _b  <= _p - 1
    assert 0 <= _Gx <= _p - 1
    assert 0 <= _Gy <= _p - 1
    assert _n != _p
    assert (4*(_a**3) + 27*(_b**2)) % _p != 0
    assert _Gy**2 % _p == (_Gx**3 + _a*_Gx + _b) % _p
    assert primes.is_prime(_p)
    assert primes.is_prime(_n)

    t = _p.bit_length() // 2
    assert _h <= 2**(t // 8)

    assert _h == math.floor((math.sqrt(_p)+1)**2 // _n)
    assert _fast_point_at(_n) == _i

    # Test to exclude curves with susceptibility to MOV, FR or SSSA attacks.
    # B_iters should be 100 (the default) for cryptographically strong curves.
    for B in range(1, B_iters):
        assert _p**B % _n != 1