"""
An implementation of the elliptic curve Diffie-Hellman (ECDH) and the elliptic curve digital
signature algorithms (ECDSA), based on the Standards for Efficient Cryptography Group's (SECG)
secp256k1 elliptic curve.
"""

from types import NoneType
import euclid
import primes
import math
import prng

# secp256k1 elliptic curve parameters (y**2 = x**3 + ax + b % p)
_p = 2**256 - 2**32 - 977
_a = 0
_b = 7
_Gx = 55066263022277343669578718895168534326250603453777594175500187360389116729240
_Gy = 32670510020758816978083085130507043184471273380659243275938904335757337482424
_G = [_Gx, _Gy]
_n = 115792089237316195423570985008687907852837564279074904382605163141518161494337
_h = 1

# Point at infinity
_i = [None, None]

# Global curve point [_x, _y] list indices.
_x = 0
_y = 1

def new_curve(p, a, b, Gx, Gy, n, h, B_iters=100):
    """
    Redefines the default (secp256k1) elliptic curve parameters, and validates
    the new ones. The parameter p is the modulus, a and b the coefficients,
    Gx and Gy the XY coordinates of the generator point, n the order of the
    point [Gx, Gy] and h the cofactor of the group generated by [Gx, Gy].
    The equation for an elliptic curve is y**2 = x**3 + ax + b % p, where x
    and y are the variables, a and b are the coefficients, and p is the modulus.
    """
    global _p, _a, _b, _Gx, _Gy, _n, _h, _G

    _p, _a, _b, _Gx, _Gy, _n, _h = p, a, b, Gx, Gy, n, h
    _G = [_Gx, _Gy]

    _validate_curve_params(B_iters)

def add(pt1, pt2):
    """
    Returns the sum of points pt1 and pt2 on the curve, according to the addition
    rules of elliptic curves; i.e., (a) the point at infinity if pt1 and pt2 are
    both the point at infinity, (b) pt2 if pt1 is the point at infinity, (c) pt1
    if pt2 is the point at infinity, (d) the point at infinity if pt1 and pt2 share
    the same x-coordinate, or (e) the sum of pt1 and pt2 on the curve.
    """
    _validate_pt(pt1)
    _validate_pt(pt2)

    if pt1 == _i and pt2 == _i:
        [x, y] = _i
    elif pt1 == _i:
        [x, y] = pt2
    elif pt2 == _i:
        [x, y] = pt1
    elif pt1 == pt2:
        [x, y] = double(pt1)
    elif pt1[_x] == pt2[_x]:
        [x, y] = _i
    else:
        slope = ((pt2[_y] - pt1[_y]) * euclid.inverse((pt2[_x] - pt1[_x]) % _p, _p)) % _p
        x = (slope**2 - (pt2[_x] + pt1[_x])) % _p
        y = ((slope * pt2[_x]) - (slope * x) - pt2[_y]) % _p
    
    return [x, y]

def double(pt):
    """
    Returns the sum of point pt and itself on the curve. If pt is the point at
    infinity, returns the point at infinity.
    """
    _validate_pt(pt)

    if pt == _i:
        return pt

    slope = (((3 * pt[_x]**2) + _a) * euclid.inverse(2 * pt[_y], _p)) % _p
    x = (slope**2 - (2 * pt[_x])) % _p
    y = ((slope * pt[_x]) - (slope * x) - pt[_y]) % _p

    return [x, y]

def generate_key():
    """
    Returns a private key d and its corresponding public key Q, where d is a
    randomly generated positive integer in the range 1 <= d < ord(G) (where 
    ord(G) is the order of the generator point), and Q is the point on the
    curve resulting from d point-additions of the generator. d, the private
    key, must be kept secret by the caller of this function. Q, the public key,
    may be shared freely.
    """
    d = _n
    while d < 1 or d >= _n:
        d = prng.randbits(_n.bit_length())

    return d, _fast_point_at(d)

def validate_key(Q):
    """
    Recommended public key validation from the Standards for Efficient Cryptography
    Group's (SECG) specification, "SEC 1: Elliptic Curve Cryptography, Version 2.0"
    (https://www.secg.org/), section 3.2.2.1 (Elliptic Curve Public Key Validation
    primitive).
    """
    _validate_pt(Q)

    # Q cannot be the point at infinity.
    assert Q != _i

    # Q's coordinates must be in the interval [0, p-1]
    assert 0 <= Q[_x] < _p - 1
    assert 0 <= Q[_y] < _p - 1

    # Q must be on the curve.
    assert Q[_y]**2 % _p == (Q[_x]**3 + (_a*Q[_x]) + _b) % _p

    # The order _n of the curve group times any Q on the curve must equal the
    # point at infinity (redundant, and costly, if _h == 1).
    if _h > 1:
        assert _x_times_pt(_n, Q) == _i

def _fast_point_at(d):
    """
    Returns the point on the curve at d point-additions of the generator point,
    where d is a positive integer in the range 1 <= d < ord(G), and ord(G) is the
    order of the generator. In contrast with the function _point_at, this function
    runs in O(log2(n)) (logarithmic) time.
    """
    assert 0 < d <= _n

    return _x_times_pt(d, _G)

def _x_times_pt(x, pt):
    """
    Returns the point on the curve at x point-additions of the start point pt, or
    the point at infinity...
    """
    _validate_pt(pt)
    assert isinstance(x, int)

    start_pt = pt
    for i in range(x.bit_length()-2, -1, -1):
        pt = double(pt)
        if (x>>i) & 1:
            pt = add(start_pt, pt)

    return pt

def _point_at(d):
    """
    Returns the point on the curve at d point-additions of the generator point,
    where d is a positive integer in the range 1 <= d < ord(G), and ord(G) is the
    order of the generator. In contrast with the function _fast_point_at, this function
    runs in O(n) (linear) time.
    """
    assert isinstance(d, int)
    assert 0 < d <= _n

    pt = _G
    for _ in range(1, d):
        pt = add(_G, pt)

    return pt

def _validate_pt(pt):
    assert isinstance(pt, list)
    assert len(pt) == 2
    if isinstance(pt[_x], int):
        assert isinstance(pt[_x], int)
        assert isinstance(pt[_y], int)
    else:
        assert isinstance(pt[_x], NoneType)
        assert isinstance(pt[_y], NoneType)

def _validate_curve_params(B_iters=100):
    """
    Recommended curve parameter validation from the Standards for Efficient Cryptography
    Group's (SECG) specification, "SEC 1: Elliptic Curve Cryptography, Version 2.0"
    (https://www.secg.org/), section 3.1.1.2.1 (Elliptic Curve Domain Parameters over
    Fp Validation Primitive).
    """
    assert B_iters >= 1
    assert 0 <= _a  <= _p - 1
    assert 0 <= _b  <= _p - 1
    assert 0 <= _Gx <= _p - 1
    assert 0 <= _Gy <= _p - 1
    assert _n != _p
    assert (4*(_a**3) + 27*(_b**2)) % _p != 0
    assert _Gy**2 % _p == (_Gx**3 + _a*_Gx + _b) % _p
    assert primes.is_prime(_p)
    assert primes.is_prime(_n)

    t = _p.bit_length() // 2
    assert _h <= 2**(t // 8)

    assert _h == math.floor((math.sqrt(_p)+1)**2 // _n)
    assert _fast_point_at(_n) == _i

    # Test to exclude curves with susceptibility to MOV, FR or SSSA attacks.
    # B_iters should be 100 (the default) for cryptographically strong curves.
    for B in range(1, B_iters):
        assert _p**B % _n != 1