"""
An implementation of the elliptic curve Diffie-Hellman (ECDH) and the elliptic curve digital
signature algorithms (ECDSA), based on the Standards for Efficient Cryptography Group's (SECG)
secp256k1 elliptic curve.
"""

from types import NoneType
import euclid
import primes
import math
import prng
import util

# secp256k1 elliptic curve parameters (y**2 = x**3 + ax + b % p)
_p = 2**256 - 2**32 - 977
_a = 0
_b = 7
_Gx = 55066263022277343669578718895168534326250603453777594175500187360389116729240
_Gy = 32670510020758816978083085130507043184471273380659243275938904335757337482424
_G = [_Gx, _Gy]
_n = 115792089237316195423570985008687907852837564279074904382605163141518161494337
_h = 1

# Point at infinity
_i = [None, None]

# Global curve point [_x, _y] list indices.
_x = 0
_y = 1

def new_curve(p, a, b, Gx, Gy, n, h, B_iters=100):
    """
    Redefines the default (secp256k1) elliptic curve parameters, and validates
    the new ones. The parameter p is the modulus, a and b the coefficients,
    Gx and Gy the xy-coordinates of the base point, n the order of the
    base point [Gx, Gy] and h the cofactor of the group generated by [Gx, Gy].
    The equation for an elliptic curve is y**2 = x**3 + ax + b % p, where x
    and y are points on the curve (variable), a and b are the coefficients
    (constant), and p is the prime modulus.
    """
    global _p, _a, _b, _Gx, _Gy, _n, _h, _G

    _p, _a, _b, _Gx, _Gy, _n, _h = p, a, b, Gx, Gy, n, h
    _G = [_Gx, _Gy]

    validate_curve_params(B_iters)

def add(pt1, pt2):
    """
    Returns the sum of points pt1 and pt2 on the curve, according to the addition
    rules of elliptic curves; i.e., (a) the identity element if pt1 and pt2 are
    both the the identity element, (b) pt2 if pt1 is the identity element, (c) pt1
    if pt2 is the identity element, (d) the identity element if pt1 and pt2 share
    the same x-coordinate, or (e) the sum of pt1 and pt2 on the curve. The identity
    element in a group of points on an elliptic curve is called the "point at
    infinity."
    """
    _validate_pt(pt1)
    _validate_pt(pt2)

    if pt1 == _i and pt2 == _i:
        [x, y] = _i
    elif pt1 == _i:
        [x, y] = pt2
    elif pt2 == _i:
        [x, y] = pt1
    elif pt1 == pt2:
        [x, y] = double(pt1)
    elif pt1[_x] == pt2[_x]:
        [x, y] = _i
    else:
        [x, y] = _add(pt1, pt2)
    
    return [x, y]

def _add(pt1, pt2):
    # This equation gives us the vertical reflection of the 3rd point of intersection
    # of a straight line through two points (i.e., pt1 and pt2) on an elliptic curve.
    # The vertical reflection of a point (x,y) is (x,-y), and vice versa.
    slope = ((pt2[_y] - pt1[_y]) * euclid.inverse((pt2[_x] - pt1[_x]) % _p, _p)) % _p
    x = (slope**2 - (pt2[_x] + pt1[_x])) % _p
    y = ((slope * pt2[_x]) - (slope * x) - pt2[_y]) % _p

    return [x, y]

def double(pt):
    """
    Returns the sum of point pt and itself on the curve. If pt is the point at
    infinity, returns the point at infinity.
    """
    _validate_pt(pt)

    if pt == _i:
        return pt

    return _double(pt)

def _double(pt):
    # This equation gives us the vertical reflection of the point of intersection of
    # a straight line that is tangent to the curve at a single point (i.e., pt) on
    # an elliptic curve. The vertical reflection of a point (x,y) is (x,-y), and vice
    # versa.
    slope = (((3 * pt[_x]**2) + _a) * euclid.inverse(2 * pt[_y], _p)) % _p
    x = (slope**2 - (2 * pt[_x])) % _p
    y = ((slope * pt[_x]) - (slope * x) - pt[_y]) % _p

    return [x, y]

def generate_keypair():
    """
    Returns a private key d and its corresponding public key Q, where d is a randomly
    generated positive integer in the range 1 <= d < _n (where _n is the order of the
    base point _G), and Q is the point on the curve resulting from d point-additions
    of the base point. d, the private key, must be kept secret by the caller of this
    function. Q, the public key, may be shared freely.
    """
    d = _n
    while not _is_valid_d(d):
        d = prng.randbits(_n.bit_length())

    return d, _fast_point_at(d)

def generate_session_key(d_priv, Q_pub):
    """
    Returns a hashed byte array to be used as a session key in a symmetric cipher
    agreed upon by both parties in the setup phase (e.g., AES, 3DES). This key must
    be kept secret by the caller of this function.
    """
    assert _is_valid_d(d_priv)
    validate_pub_key(Q_pub)

    # Compute a session key using the essential property of Diffie-Hellman which, in
    # the case of elliptic curves, means multiplication of the other party's public key
    # Q_pub by the caller's private key d_priv).
    ki = x_times_pt(d_priv, Q_pub)

    # Hash ki to obscure any mathematical structure in it that could be exploited by an
    # adversary if it were to be leaked.
    return util.hash(ki)

def _is_valid_d(d):
    # Private keys must fall in the range 1 <= d < _n
    return isinstance(d, int) and 1 <= d < _n

def sign(m, d):
    """
    Returns a signature S&mdash;a tuple of the form (r, s)&mdash;that is computed by
    signing the message m with the caller's private key d.
    """
    assert _is_valid_d(d)

    s = 0
    while s == 0:
        r = 0
        while r == 0:
            # k is the ephemeral (i.e., one-time use) key.
            k, R = generate_keypair()
            assert 0 <= R[_x] < _p

            # r is the x-coordinate of R; the first element of the tuple (r, s)
            # returned by this function (try again if r is 0).
            r = R[_x] % _n

        # Convert m to an integer representative of its hash.
        e = _hash_to_int(m)

        # Compute the second element of the tuple (r, s) returned by this function
        # (try again if s is 0).
        s = (euclid.inverse(k, _n) * (e + d * r)) % _n

    return r, s

def verify(m, S, Q):
    """
    Returns True if the signature S&mdash;a tuple of the form (r, s)&mdash; is valid
    for the message m and a public key Q; otherwise returns False.
    """
    validate_pub_key(Q)

    r, s = S[0], S[1]

    # Convert m to an integer representative of its hash.
    e = _hash_to_int(m)

    u1 = (e * euclid.inverse(s, _n)) % _n
    u2 = (r * euclid.inverse(s, _n)) % _n

    # Recover the point computed in the signing operation.
    R = add(x_times_pt(u1, _G), x_times_pt(u2, Q))
    assert R != _i

    v = R[_x] % _n

    return v == r

def _hash_to_int(m):
    """
    Converts a message m to an integer representation of its hash.
    """
    h = util.hash(m)
    hi = int.from_bytes(h, byteorder="big")

    if _n.bit_length() >= hi.bit_length():
        e = hi
    else:
        # Use only the leftmost _n bits if _n is smaller than m.
        e = hi >> (hi.bit_length() - _n.bit_length())

    return e

def _fast_point_at(d):
    """
    Returns the point on the curve at d point-additions of the generator point,
    where d is a positive integer in the range 1 <= d < ord(G), and ord(G) is the
    order of the generator. In contrast with the function _point_at, this function
    runs in O(log2(n)) (logarithmic) time.
    """
    assert isinstance(d, int) and 0 < d <= _n

    return x_times_pt(d, _G)

def x_times_pt(x, pt):
    """
    Returns the point on the curve at x point-additions of the start point pt, or
    the point at infinity...
    """
    _validate_pt(pt)
    assert isinstance(x, int) and x > 0

    start_pt = pt
    for i in range(x.bit_length()-2, -1, -1):
        pt = double(pt)
        if (x>>i) & 1:
            pt = add(start_pt, pt)

    return pt

def _point_at(d):
    """
    Returns the point on the curve at d point-additions of the generator point,
    where d is a positive integer in the range 1 <= d < ord(G), and ord(G) is the
    order of the generator. In contrast with the function _fast_point_at, this function
    runs in O(n) (linear) time.
    """
    assert isinstance(d, int) and 0 < d <= _n

    pt = _G
    for _ in range(1, d):
        pt = add(_G, pt)

    return pt

def _validate_pt(pt):
    assert isinstance(pt, list)
    assert len(pt) == 2
    assert (isinstance(pt[_x], int)      and isinstance(pt[_y], int))\
        or (isinstance(pt[_x], NoneType) and isinstance(pt[_y], NoneType))

def validate_pub_key(Q):
    """
    Recommended public key validation from the Standards for Efficient Cryptography
    Group's (SECG) specification, "SEC 1: Elliptic Curve Cryptography, Version 2.0"
    (https://www.secg.org/), section 3.2.2.1 (Elliptic Curve Public Key Validation
    primitive).
    """
    _validate_pt(Q)

    valid = True

    # Q must not be the identity element.
    if valid and Q == _i:
        valid = False

    # Q's x coordinate must be in the interval [0, p-1].
    if valid and Q[_x] > _p-1 or Q[_x] < 0:
        valid = False

    # Q's y coordinate must be in the interval [0, p-1].
    if valid and Q[_y] > _p-1 or Q[_y] < 0:
        valid = False

    # Q must be on the curve
    if valid and Q[_y]**2 % _p != (Q[_x]**3 + (_a*Q[_x]) + _b) % _p:
        valid = False

    # If the cofactor _h is greater than 1, then the order of the group _n times Q must
    # equal the identity element.
    if valid and _h > 1 and x_times_pt(_n, Q) != _i:
        valid = False

    if not valid:
        raise ValueError("Invalid public key")

def validate_curve_params(B_iters=100):
    """
    Recommended curve parameter validation from the Standards for Efficient Cryptography
    Group's (SECG) specification, "SEC 1: Elliptic Curve Cryptography, Version 2.0"
    (https://www.secg.org/), section 3.1.1.2.1 (Elliptic Curve Domain Parameters over
    Fp Validation Primitive).
    """

    # Check that
    # (1) _a, _b, _Gx and _Gy are all in the interval [0,_p-1],
    # (2) _n != _p,
    # (3) the curve is smooth,
    # (4) The base point _G, formed by [_Gx,_Gy], is on the curve,
    # (5) _p and _n are both prime,
    # (6) the point at the order of the curve _n, times the base point _G, equals the
    # identity element (aka the point at infinity),
    # (7) the cofactor _h is correct and
    # (8) the curve is not susceptible to the MOV, FR or SSSA attacks (B_iters should be 100
    # (the default) for cryptographically strong curves).
    valid = True

    # _a must be in the interval [0, _p-1].
    if valid and _a > _p - 1 or _a < 0:
        valid = False

    # _b must be in the interval [0, _p-1].
    if valid and _b > _p - 1 or _b < 0:
        valid = False

    # _Gx must be in the interval [0, _p-1].
    if valid and _Gx > _p - 1 or _Gx < 0:
        valid = False

    # _Gy must be in the interval [0, _p-1].
    if valid and _Gy > _p - 1 or _Gy < 0:
        valid = False

    # _n must not equal _p.
    if valid and _n == _p:
        valid = False

    # The curve must be smooth
    if valid and (4*(_a**3) + 27*(_b**2)) % _p == 0:
        valid = False

    # The base point [_Gx, _Gy] must be on the curve.
    if valid and _Gy**2 % _p != (_Gx**3 + _a*_Gx + _b) % _p:
        valid = False

    # _p must be prime
    if valid and not primes.is_prime(_p):
        valid = False

    # _n must be prime
    if valid and not primes.is_prime(_n):
        valid = False

    # _n additions of the base point _G must yield the identity element.
    if valid and _fast_point_at(_n) != _i:
        valid = False

    # The following two tests are for the cofactor _h.
    if valid and _h != math.floor((math.sqrt(_p)+1)**2 // _n):
        valid = False

    if valid and _h > 2**((_p.bit_length() // 2) // 8):
        valid = False

    # Check that the curve is not susceptible to the MOV, FR or SSSA attacks
    # (B_iters should be 100 (the default) for cryptographically strong curves).
    if valid and B_iters < 1:
        valid = False
    else:
        for B in range(1, B_iters):
            if _p**B % _n == 1:
                valid = False

    if not valid:
        raise ValueError("Invalid curve")