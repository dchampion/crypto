"""
An implementation of the elliptic curve Diffie-Hellman (ECDH) and the elliptic
curve digital signature algorithms (ECDSA), based on the Standards for Efficient
Cryptography Group's (SECG) secp256k1 elliptic curve.
"""

import euclid
import primes
import math
import prng
import util

# secp256k1 elliptic curve parameters:
# field parameter (p) -> prime modulus in the curve equation y**2 = x**3 + ax + b (mod p)
_p = 2**256 - 2**32 - 977
# coefficient (a) in curve equation
_a = 0
# coefficient (b) in curve equation
_b = 7
# Base/generator point (G) x-coordinate
_Gx = 55066263022277343669578718895168534326250603453777594175500187360389116729240
# Base/generator point (G) y-coordinate
_Gy = 32670510020758816978083085130507043184471273380659243275938904335757337482424
# Base/generator point (G)
_G = [_Gx, _Gy]
# Order (n) of base/generator point (G) -> such that nG = i, where i is the identity element
_n = 115792089237316195423570985008687907852837564279074904382605163141518161494337
# cofactor (h) -> where h is the order of the curve (written as #E(Fp)) divided by n
_h = 1

# Identity element, aka the point at infinity
_i = [None, None]

# Global curve point [x, y] list indices.
X = 0
Y = 1

def new_curve(p, a, b, Gx, Gy, n, h, B_iters=100):
    """
    Redefines the default (secp256k1) elliptic curve parameters, and validates
    the new ones. The parameter p is the field parameter (or modulus), a and b
    the curve coefficients, Gx and Gy the xy-coordinates of the base point on
    the curve, n the order of the base point [Gx, Gy] and h the cofactor of the
    subgroup generated by [Gx, Gy]. The equation for an elliptic curve is
    y**2 = x**3 + ax + b % p, where x and y are points on the curve (variable),
    a and b are the curve coefficients (constant), and the p is the prime modulus.
    """
    global _p, _a, _b, _Gx, _Gy, _n, _h, _G

    _p, _a, _b, _Gx, _Gy, _n, _h = p, a, b, Gx, Gy, n, h
    _G = [_Gx, _Gy]

    validate_curve_params(B_iters)

def add(pt1, pt2):
    """
    Returns the sum of points pt1 and pt2 on the curve, according to the addition
    rules of elliptic curves; i.e., (a) the identity element if pt1 and pt2 are
    both the the identity element, (b) pt2 if pt1 is the identity element, (c) pt1
    if pt2 is the identity element, (d) the identity element if pt1 and pt2 share
    the same x-coordinate, or (e) the sum of pt1 and pt2 on the curve.
    """
    _validate_pt(pt1)
    _validate_pt(pt2)

    if pt1 == _i and pt2 == _i:
        [x, y] = _i
    elif pt1 == _i:
        [x, y] = pt2
    elif pt2 == _i:
        [x, y] = pt1
    elif pt1 == pt2:
        [x, y] = double(pt1)
    elif pt1[X] == pt2[X]:
        [x, y] = _i
    else:
        [x, y] = _add(pt1, pt2)
    
    return [x, y]

def double(pt):
    """
    Returns the sum of point pt with itself on the curve. If pt is the point at
    infinity, returns the point at infinity.
    """
    _validate_pt(pt)

    if pt == _i:
        return pt

    return _double(pt)

def _add(pt1, pt2):
    return _additive_inverse(_secant_intersection(pt1, pt2))

def _double(pt):
    return _additive_inverse(_tangent_intersection(pt))

def _additive_inverse(pt):
    # Returns the additive inverse of pt, where pt is of the form [x, y], and pt's
    # inverse is [x, -y].
    return [pt[X], -pt[Y] % _p]

def _tangent_intersection(pt):
    # Returns the point of intersection on the curve of a straight line drawn tangent
    # to the point pt on the curve.

    # The slope (m) of a line tangent to pt is given by the equation 3x**2 + a / 2y.
    # Because we are working in a finite group, we can't do division, however, so we
    # multiply the numerator by the inverse of the denominator (all modulo _p of course).
    # We obtain this equation by differentiating both sides of the curve equation
    # y**2 = x**3 + ax + b, which yields m * 2y = 3x**2 + a, or m = 3x**2 + a / 2y.
    m = (((3 * pt[X]**2) + _a) * euclid.inverse(2 * pt[Y], _p)) % _p

    # The sum of the three roots of a cubic polynomial, in which the coefficient of the
    # highest power of x is 1 (aka a monic polynomial), is equal to the negative of the
    # coefficient of the second-highest power of x. In this case two of the three roots
    # are the same (pt[X]), and the third root is the intersection at pt2[X]. In the
    # equation y**2 = x**3 + ax + b, the value of that coefficient is m**2. If we consider
    # that the equation for a line that runs tangent to pt is y = mx + B, we can rewrite the
    # curve equation as (mx + B)**2 = x**3 + ax + b, or x**3 - (mx + B)**2 + ax + b = 0.
    # This gives us -m**2, which is the coefficient of -x**2, the negative of which is
    # m**2. Since pt[X] + pt[X] + pt2[X] = m**2, then pt2[X] = m**2 - pt[X] - pt[X],
    # or pt2[X] = m**2 - 2 * pt[X].
    pt2 = []
    pt2.append((m**2 - (2 * pt[X])) % _p)

    # Since pt2 must lie on the curve where the line tangent to pt intersects it, and
    # since y = mx + B, we can write pt2[Y] = m*pt2[X] + B, or pt2[Y] = m*pt2[X] + (pt[Y]
    # - m*pt[X]), or pt2[Y] = m(pt2[X] - pt[X]) + pt[Y].
    pt2.append((m * (pt2[X] - pt[X])) + pt[Y] % _p)

    return pt2

def _secant_intersection(pt1, pt2):
    # Returns the point of intersection on the curve of a straight line drawn between
    # points pt1 and pt2 (i.e., the secant line) on the curve.

    # The slope (m) of the line through pt1 and pt2 is given by the equation
    # pt2[Y] - pt1[Y] / pt2[X] - pt1[X]. Because we are working in a finite group, we
    # can't do division, however, so we multiply the numerator by the inverse of the
    # denominator (all modulo _p of course).
    m = ((pt2[Y] - pt1[Y]) * euclid.inverse((pt2[X] - pt1[X]) % _p, _p)) % _p

    # The sum of the three roots of a cubic polynomial, in which the coefficient of the
    # highest power of x is 1 (aka a monic polynomial), is equal to the negative of the
    # coefficient of the second-highest power of x. In the equation y**2 = x**3 + ax + b,
    # that value is m**2. If we consider that the equation for a line that runs through
    # pt1 and pt2 is y = mx + B, we can rewrite the curve equation as (mx + B)**2 =
    # x**3 + ax + b, or x**3 - (mx + B)**2 + ax + b = 0. This gives us -m**2, which is
    # the coefficient of -x**2, the negative of which is m**2. Since pt1[X] + pt2[X]
    # + pt3[X] = m**2, then pt3[X] = m**2 - pt1[X] - pt2[X].
    pt3 = []
    pt3.append((m**2 - pt1[X] - pt2[X]) % _p)

    # Since pt3 must be on the line between pt1 and pt2, and y = mx + B, we can write
    # pt3[Y] = mx + B, or pt3[Y] = m*pt3[X] + (pt1[Y] - m*pt1[X]), or pt3[Y] =
    # m(pt3[X] - pt1[X]) + pt1[Y] (note that pt1 could be substituted for pt2 in this
    # equation with the same effect).
    pt3.append((m * (pt3[X] - pt1[X]) + pt1[Y]) % _p)

    return pt3

def generate_keypair():
    """
    Returns a private key d and its corresponding public key Q, where d is a
    randomly generated positive integer in the range 1 <= d < n (where n is the
    order of the base point), and Q is the point on the curve resulting from d
    point-additions of the base point. d, the private key, must be kept secret by
    the caller of this function. Q, the public key, may be shared freely.
    """
    d = _n
    while not _validate_priv_key(d):
        d = prng.randbits(_n.bit_length())

    return d, _fast_point_at(d)

def generate_session_key(d, Q):
    """
    Returns a byte array to be used as a session key in a symmetric cipher agreed
    upon in advance by communicating parties (e.g., AES, 3DES). This key must be
    kept secret by the caller of this function.
    """
    assert _validate_priv_key(d)
    validate_pub_key(Q)

    # Compute a shared point on the curve using the essential property of Diffie-
    # Hellman. In the case of elliptic curves, this is done by multiplying the
    # other party's public key Q by the caller's private key d.
    k_pt = x_times_pt(d, Q)

    # Use only the x-coordinate of the shared point in the shared key, and hash it
    # to obscure any mathematical structure that could be exploited by an adversary
    # if it were to be leaked.
    return util.hash(k_pt[X])

def sign(d, m):
    """
    Returns a signature S&mdash;a tuple of the form (r, s)&mdash;that is computed
    by signing the message m with the caller's private key d.
    """
    assert _validate_priv_key(d)

    s = 0
    while s == 0:
        r = 0
        while r == 0:
            # k is the ephemeral (i.e., one-time use) key.
            k, R = generate_keypair()
            assert 0 <= R[X] < _p

            # r is the x-coordinate of R; the first element of the tuple (r, s)
            # returned by this function (try again if r is 0).
            r = R[X] % _n

        # Convert m to an integer representative of its hash.
        e = _hash_to_int(m)

        # Compute the second element of the tuple (r, s) returned by this function
        # (try again if s is 0).
        s = (euclid.inverse(k, _n) * (e + d * r)) % _n

    return r, s

def verify(Q, m, S):
    """
    Returns True if the signature S&mdash;a tuple of the form (r, s)&mdash; is
    valid for the message m and a public key Q; otherwise returns False.
    """
    validate_pub_key(Q)

    r, s = S[0], S[1]
    assert 1 <= r < _n
    assert 1 <= s < _n

    # Convert m to an integer representative of its hash.
    e = _hash_to_int(m)

    u1 = (e * euclid.inverse(s, _n)) % _n
    u2 = (r * euclid.inverse(s, _n)) % _n

    # Recover the point computed in the signing operation.
    R = add(x_times_pt(u1, _G), x_times_pt(u2, Q))
    assert R != _i

    v = R[X] % _n

    return v == r

def _hash_to_int(m):
    """
    Converts a message m to an integer representation of its hash.
    """
    h = util.hash(m)
    hi = int.from_bytes(h, byteorder="big")

    if _n.bit_length() >= hi.bit_length():
        e = hi
    else:
        # Use only the leftmost _n bits if _n is smaller than m.
        e = hi >> (hi.bit_length() - _n.bit_length())

    return e

def _fast_point_at(d):
    """
    Returns the point on the curve at d point-additions of the base point, where
    d is a positive integer in the range 1 <= d < n, and n is the order of the
    base point. In contrast with the function _point_at, this function runs in
    logarithmic time.
    """
    assert isinstance(d, int) and 0 < d <= _n

    return x_times_pt(d, _G)

def x_times_pt(x, pt):
    """
    Returns the point on the curve at x point-additions of the start point pt.
    """
    _validate_pt(pt)
    assert isinstance(x, int) and x > 0

    start_pt = pt
    for i in range(x.bit_length()-2, -1, -1):
        pt = double(pt)
        if (x>>i) & 1:
            pt = add(start_pt, pt)

    return pt

def _point_at(d):
    """
    Returns the point on the curve at d point-additions of the base point, where
    d is a positive integer in the range 1 <= d < n, and n is the order of the
    base point. In contrast with the function _fast_point_at, this function runs
    in linear time.
    """
    assert isinstance(d, int) and 0 < d <= _n

    pt = _G
    for _ in range(1, d):
        pt = add(_G, pt)

    return pt

def _validate_pt(pt):
    # pt must be a 2-element list.
    assert isinstance(pt, list) and len(pt) == 2

    # pt's types must match.
    assert type(pt[X]) == type(pt[Y])

    if isinstance(pt[X], int):
        # If pt is purported to be a point on the curve, prove that it is.
        assert on_curve(pt)
    else:
        # If pt's elements are not of type int, then they must be of type None.
        assert pt[X] == None and pt[Y] == None

def on_curve(pt):
    """
    Returns True if the point pt is on the curve; otherwise returns False.
    """
    return pt[Y]**2 % _p == (pt[X]**3 + (_a*pt[X]) + _b) % _p

def _validate_priv_key(d):
    # Private keys must fall in the range 1 <= d < _n
    return isinstance(d, int) and 1 <= d < _n

def validate_pub_key(Q):
    """
    Recommended public key validation from the Standards for Efficient Cryptography
    Group's (SECG) specification, "SEC 1: Elliptic Curve Cryptography, Version 2.0"
    (https://www.secg.org/), section 3.2.2.1 (Elliptic Curve Public Key Validation
    primitive).
    """
    _validate_pt(Q)

    valid = True

    # Q must not be the identity element.
    if valid and Q == _i:
        valid = False

    # Q's x coordinate must be in the interval [0, p-1].
    if valid and Q[X] > _p-1 or Q[X] < 0:
        valid = False

    # Q's y coordinate must be in the interval [0, p-1].
    if valid and Q[Y] > _p-1 or Q[Y] < 0:
        valid = False

    # Q must be on the curve
    if valid and Q[Y]**2 % _p != (Q[X]**3 + (_a*Q[X]) + _b) % _p:
        valid = False

    # If the cofactor _h is greater than 1, then the order of the group _n times Q must
    # equal the identity element.
    if valid and _h > 1 and x_times_pt(_n, Q) != _i:
        valid = False

    if not valid:
        raise ValueError("Invalid public key")

def validate_curve_params(B_iters=100):
    """
    Recommended curve parameter validation from the Standards for Efficient Cryptography
    Group's (SECG) specification, "SEC 1: Elliptic Curve Cryptography, Version 2.0"
    (https://www.secg.org/), section 3.1.1.2.1 (Elliptic Curve Domain Parameters over
    Fp Validation Primitive).
    """

    valid = True

    # _a must be a group element; i.e., within the interval [0, _p-1].
    if valid and _a > _p - 1 or _a < 0:
        valid = False

    # _b must be a group element; i.e., within the interval [0, _p-1].
    if valid and _b > _p - 1 or _b < 0:
        valid = False

    # _Gx must be a group element; i.e., within the interval [0, _p-1].
    if valid and _Gx > _p - 1 or _Gx < 0:
        valid = False

    # _Gy must be a group element; i.e., within the interval [0, _p-1].
    if valid and _Gy > _p - 1 or _Gy < 0:
        valid = False

    # _n must not equal _p.
    if valid and _n == _p:
        valid = False

    # The curve must be smooth.
    if valid and (4*(_a**3) + 27*(_b**2)) % _p == 0:
        valid = False

    # The base point _G must be on the curve.
    if valid and not on_curve(_G):
        valid = False

    # _p must be prime.
    if valid and not primes.is_prime(_p):
        valid = False

    # _n must be prime.
    if valid and not primes.is_prime(_n):
        valid = False

    # _n additions of the base point _G must yield the identity element.
    if valid and _fast_point_at(_n) != _i:
        valid = False

    # The following two tests are for the cofactor _h.
    if valid and _h != math.floor((math.sqrt(_p)+1)**2 // _n):
        valid = False

    if valid and _h > 2**((_p.bit_length() // 2) // 8):
        valid = False

    # Check that the curve is not susceptible to the MOV, FR or SSSA attacks
    # (B_iters should be 100 (the default) for cryptographically strong curves).
    if valid and B_iters < 1:
        valid = False
    else:
        for B in range(1, B_iters):
            if _p**B % _n == 1:
                valid = False

    if not valid:
        raise ValueError("Invalid curve")